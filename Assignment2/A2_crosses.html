<!-- ASSIGNMENT 2 BY MASHA KROTKYKH & ALESSIA SIGNORINO -->
<!-- References: Sabine Rosenberg's examples and https://developer.mozilla.org/en-US/docs/Web/API/ -->

<!DOCTYPE html>
<html>
<head>
<title>ASSIGNMENT 2 - MASHA/ALESSIA</title>
<style>
  body {
    margin: 0;
    padding: 0;
  }
  canvas {
    background: #F4EADE;
  }
</style>
<script>
  window.onload = function(){

    // get canvas context, make it browser window size, get audio context
    let canvas = document.getElementById("testCanvas");
    let context = canvas.getContext("2d");
    context.canvas.width  = window.innerWidth;
    context.canvas.height = window.innerHeight;
    let audioContext = new (window.AudioContext || window.webkitAudioContext)();

    //Empty array of crosses
    let shapeList = [];
    const NUM_SHAPES = 10;
    // let colors = ["#2988BC","2F496E","ED8C72"]; //to try add diff colors or dlt later

    //Max and Min values for valClamp
    let min = -19050;
    let max = 19050;

    // Menu buttons array
	  let myButtons = [];
	  const MAX_BUTTONS =3;

    // On 1-2-3  key pressed shapes change
    document.onkeypress = function() {
        shapeshift()
    };

   //Event listeners for click & hover
    canvas.addEventListener("mousedown", function(event){
    	// console.log("canvas mouse clicked");
        for(let i=0; i<NUM_SHAPES; i++){
          shapeList[i].hitTest(event);
        }
        for (let i =0; i< myButtons.length;i++){
        myButtons[i].hitTestDown(event);
      }
    });
    canvas.addEventListener("mouseover", function(event){
      // console.log("canvas mouse over");
      //Collision detection for each shape
      for(let i=0; i<NUM_SHAPES; i++){
        shapeList[i].hitTestOver(event);
      }
    });
    // added SABINE -> if was over and now mouse moves ensure that is still over
    canvas.addEventListener("mousemove", function(event){
      // console.log("canvas mouse over");
      //Collision detection
      for(let i=0; i<NUM_SHAPES; i++){
        shapeList[i].hitTestMove(event);
      }
    });

    // When cursor is outside canvas, rotation stops
    canvas.onmouseout = function() {
      console.log("Ooopsey");
      zoneOut = true;
    };

    // generate shapes (push into array)
    for(let i=0; i<NUM_SHAPES; i++){
      let r = 0;
      let g = 0;
      let b = 0;
      let a = 1.0;
      let rSpeed = 2; //will vary
      let size = Math.floor((Math.random()*canvas.width/10)+10);
      let x = Math.floor((Math.random()*canvas.width));
      let y = Math.floor((Math.random()*canvas.height));
      // let h = Math.floor((Math.random()*10)+1);
      // let w = h*10;
      // let xx = x + w/2 - h/2;
      // let yy = y - w/2 + h/2;

      let zoneOut = false;
      let cross = true;
      let circle = false;
      let square = false;

      shapeList.push(new CustomShape(x,y,size,size,r,g,b,a,i,(i%6)+2));
      // shapeList.push(new CustomShape(x,y,xx,yy,w,h,r,g,b,a,colors[NUM_SHAPES%colors.length],i,(i%6)+2));
    }

    //fill buttons array with button objects
    for (let i =0; i< MAX_BUTTONS;i++){
      let objW = canvas.width/40;
      let offset =10;
      let color = "#808096";
      myButtons.push(new myPushyButton(objW, objW + ((objW+offset)*i),objW/2,i,color));
    }

    // recursive animation function
    requestAnimationFrame(run);

    function run(){
      context.clearRect(0, 0, canvas.width, canvas.height);

      for(let i=0; i<NUM_SHAPES; i++){
        shapeList[i].display();
        //if the isOver boolean is true -> play the sound...
        shapeList[i].playSoundIfOver();
        shapeList[i].playDistortionIfPressed();
      }
      //initial display of buttons
      for(let i=0; i< myButtons.length;i++){
        myButtons[i].render();
      }
      requestAnimationFrame(run);
    }

    // Function that defines which shapes will be displayed
      function shapeshift(button) {
        if(event.keyCode === 49 || button === 0) {
          console.log('this is button ${button}');
          cross = true;
          circle = false;
          square = false;
        }
        else if(event.keyCode === 50 || button === 1) {
          console.log("2 key is pressed");
          cross = false;
          circle = true;
          square = false;
        }
        else if(event.keyCode === 51 || button === 2) {
          console.log("3 key is pressed");
          cross = false;
          circle = false;
          square = true;
        }
      }

    // Cross Object
    function CustomShape(x,y,size,size,r,g,b,a,c,eid,rSpeed){
        //constructor
        this.x = x;
        this.y = y;
        // this.xx = xx;
        // this.yy = yy;
        // this.w = w;
        // this.h = h;
        this,size = size;
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        this.c = c; // to delete later

        this.eID = eid;
        this.isOver = false; // for freqVal
        this.isPressed = false; // for distortion
        this.cChange = 10;
        this.cFade = 1;

        this.theta = 0;
        this.rSpeed = 0; // use this to change distortion
        this.maxrSpeed = .5;

        this.note = new Sound(audioContext);
        this.freqVal = 220 + (eid*128);
        // this.freqVal =  220*rSpeed; //in this case freq changes on rSpeed
        // console.log("freqVal is:::"+this.freqVal);

        // display (press affects RGB)
        this.display = function(){

          if(this.isPressed === true) {

          	if(this.r <= 0) {
          		this.r +=this.cChange;
          	}
          	else if(this.r >= 150) {
          		this.r -=this.cChange;
          	}
          	else if(this.r > 0 && this.r < 150) {
          		this.r -= Math.floor((Math.random()*5)-3);
          	}

          	if(this.g <= 0) {
          		this.g +=this.cChange;
          	}
          	else if(this.g >= 150) {
          		this.g -=this.cChange;
          	}
          	else if(this.g > 0 && this.g < 150) {
          		this.g -= Math.floor((Math.random()*5)-3);
          	}

          	if(this.b <= 0) {
          		this.b +=this.cChange;
          	}
          	else if(this.b >= 150) {
          		this.b -=this.cChange;
          	}
          	else if(this.b > 0 && this.b < 150) {
          		this.b -= Math.floor((Math.random()*5)-3);
          	}

          }

          else if(this.isPressed ===false) {
          	if(this.r > 0) {
          		this.r -= this.cFade;
          	}
          	if(this.g > 0) {
          		this.g -= this.cFade;
          	}
          	if(this.b > 0) {
          		this.b -= this.cFade;
          	}
          }

      // Color
		  this.col = "rgba("+this.r+","+this.g+","+this.b+","+this.a+")";
      context.fillStyle = this.col;

      // Rotation
      context.save();
      context.translate(this.x, this.y);
      context.rotate(this.theta);

      // Speed dependent on hover
      if(zoneOut === false && this.isOver ===true && this.rSpeed <= this.maxrSpeed) {
        if(this.rSpeed < .1) {
          this.rSpeed = .1;
        }
        else {
          this.rSpeed += 0.001;
        }
      }
      else if((this.isOver ===false || zoneOut === true) && this.rSpeed > 0){
        this.rSpeed-=0.001;
      }
			this.theta += this.rSpeed;

      // generate
      // context.fillRect(-this.w/2, -this.h/2, this.w, this.h);
      // context.fillRect(-this.h/2, -this.w/2, this.h, this.w);

      // If "1" is pressed, "CROSSES" becomes true (true by default) and crosses are displayed
      if(cross === true) {
        square = false;
        circle = false;
      	context.beginPath();
      	context.moveTo(-this.size*3, 0);
      	context.lineTo(this.size*3, 0);
      	context.lineWidth = this.size/20;
      	context.stroke();
      	context.closePath();

      	context.beginPath();
      	context.moveTo(0, -this.size*3);
      	context.lineTo(0, this.size*3);

      	context.lineWidth = this.size/20;
      	context.stroke();
      } //end of option 1

      // If "2" is pressed, "CIRCLES" becomes true (false by default) and circles are displayed
      else if(circle === true) {
        square = false;
        cross = false;
      	context.beginPath();
      	context.arc(this.size/3,this.size/3,this.size/2,0,2*Math.PI);
      	context.lineWidth = this.size/20;
      	context.stroke();
      } // end option 2

      // If "3" is pressed, "SQUARES" becomes true (false by default) and squares are displayed
      else if(square === true) {
      	cross = false;
      	circle = false;

      	let step = this.size/7;
        context.fillRect(-this.size/2-step, -this.size/2-step, this.size+step*2, this.size+step*2);
        // Draw a square spiral inside square shapes (should have done a while loop :/)
        context.beginPath();
      	context.moveTo(-this.size/2, -this.size/2);
      	context.lineTo(this.size/2, -this.size/2);
      	context.lineTo(this.size/2, this.size/2);
      	context.lineTo(-this.size/2, this.size/2);
      	context.lineTo(-this.size/2, -this.size/2+step);
      	context.lineTo(this.size/2 - step, -this.size/2+step);
      	context.lineTo(this.size/2 - step, this.size/2-step);
      	context.lineTo(-this.size/2 + step, this.size/2-step);
      	context.lineTo(-this.size/2 + step, -this.size/2+step*2);
      	context.lineTo(this.size/2 - step*2, -this.size/2+step*2);
      	context.lineTo(this.size/2 - step*2, this.size/2-step*2);
      	context.lineTo(-this.size/2 + step*2, this.size/2-step*2);
      	context.lineTo(-this.size/2 + step*2, -this.size/2+step*3);
      	context.lineTo(this.size/2 - step*3, -this.size/2+step*3);
      	context.lineTo(this.size/2 - step*3, this.size/2-step*3);
      	context.lineTo(-this.size/2 + step*3, this.size/2-step*3);
      	context.lineTo(-this.size/2 + step*3, -this.size/2+step*4);
      	context.lineWidth = this.size/40;
        context.stroke();
      } // end of option 3

      context.restore();

    } // end of display function

    this.playSoundIfOver = function(){
      // Sound will happen if mouse is over
      if(this.isOver === true){
        let now = audioContext.currentTime;
        this.note.offsetDuration = 3;
        clampedVal = valClamp(this.freqVal);
        this.note.play(clampedVal, now);
        // console.log("clampedVal:::"+clampedVal);
      }
    }

    this.playDistortionIfPressed = function(){
      if(this.isPressed === true){
        let now = audioContext.currentTime;
        this.note.offsetDuration = 3;
        console.log("inside playDistortionIfPressed");
        clampedVal = (valClamp(this.freqVal)-49);
        // this.note.filter(clampedVal,now);
        this.note.play(clampedVal,now);
        console.log("FILTERED clampedVal :::: "+clampedVal);
        // console.log("freqVal is:"+this.freqVal);
      }
    }

    // callback functions for mouse click, over and move
    this.hitTest = function(event){
      if(Math.sqrt(Math.pow((event.clientX-this.x),2)+Math.pow((event.clientY-this.y),2))<this.w){
        // console.log("rect pressed::: "+this.eID);
        console.log("PRESSED!")
        this.isPressed = !this.isPressed;
      }
    } // end of hitTest
    this.hitTestOver = function(event){
      if(Math.sqrt(Math.pow((event.clientX-this.x),2)+Math.pow((event.clientY-this.y),2))<this.w*2){
        // console.log("EID, rect over::: "+this.eID);
        this.isOver = true;
        zoneOut = false;
        //update the freq val
        this.freqVal = this.freqVal+(event.clientX/100);
      }
    } // end of hitTestOver
    //SABINE:: ADDED
    this.hitTestMove = function(event){
      if(Math.sqrt(Math.pow((event.clientX-this.x),2)+Math.pow((event.clientY-this.y),2))<this.w*2){
        // console.log("EID, rect over::: "+this.eID);
        this.isOver = true;
        //update the freq val
        this.freqVal = this.freqVal+(event.clientX/100);
      } else {
          this.isOver = false;
      }
    } // end of hitTestMove callback

  } // end of custom object

  // Clamp value to a range (freqVal)
  // if value is larger than min / smaller than max, then return value, else return min/max
  function valClamp(value) {
     return value <= min ? min : value >= max ? max : value;
  }

  /*** class for sound inspired and copy-lefted from::
  https://css-tricks.com/introduction-web-audio-api/*/
  function Sound (context) {
    this.context = context;
    this.offsetDuration =2;

    this.init =function () {

      // setting up the various audio nodes that will be used
      this.oscillator = this.context.createOscillator();
      // this.distortion = this.context.createWaveShaper();
      // this.analyser = this.context.createAnalyser();
      // this.biquadFilter = this.context.createBiquadFilter();

       //for volume
      this.gainNode = this.context.createGain();
      // this.distortionGainNode = this.context.createGain();

      // this.oscillator.connect(this.biquadFilter);
      //connecting oscillator and distortion to gainNode to speakers
      this.oscillator.connect(this.gainNode);


      this.gainNode.connect(this.context.destination);
      // this.biquadFilter.connect(this.gainNode);
      // this.distortion.connect(this.distortionGainNode);
      // this.distortionGainNode.connect(this.context.destination);
      // this.analyser.connect(this.analyser);

      this.oscillator.type = 'sawtooth';
      // this.biquadFilter.type = 'lowpass';

    }

    this.play = function (value, time) {
      this.init();
      // console.log(value);
      this.oscillator.frequency.value = value;
      //set gain
      this.gainNode.gain.setValueAtTime(0.5, this.context.currentTime);
      this.oscillator.start(time);
      // How LONG should duration of note be?
      this.stop(time+this.offsetDuration);
    } // end of play

    // this.filter = function (value,time) {
    //   this.init();
    //   this.biquadFilter.frequency.value = value;
    //   this.biquadFilter.frequency.setValueAtTime(100, this.context.currentTime);
    //   // this.biquadFilter.gain.setValueAtTime(25, this.context.currentTime);
    //   console.log("FILTER method");
    // }

//to delete
    // this.distPlay = function(value, time) {
    //   console.log("inside distPlay");
    //   this.distortion.curve = makeDistortionCurve(400);
    //   this.distortion.oversample = '4x';
    //   this.stop(time+this.offsetDuration);
    // }

    this.stop = function(time) {
      // gradual change in value
      this.gainNode.gain.exponentialRampToValueAtTime(0.001, time + 1);
      this.oscillator.stop(time + 0);
    }

// // to delete
//     this.distStop = function(time) {
//       this.distortionGainNode.gain.exponentialRampToValueAtTime(0.001, time + 1);
//       this.distortion.stop(time + 0);
//     }

    // Kevin Ennis http://stackoverflow.com/questions/22312841/waveshaper-node-in-webaudio-how-to-emulate-distortion
    // distortion, d is type of amount, if amount is a number, give amount, else put 50
    // this.makeDistortionCurve = function (amount) {
    //   console.log("inside makeDistortionCurve");
    //   let d = typeof amount === 'number' ? amount : 50,
    //   n_samples = 44100,
    //   curve = new Float32Array(n_samples),
    //   deg = Math.PI/180,
    //   i=0,
    //   x;
    //   for (;i<this.n_samples;++i) {
    //     x=i*2/this.n_samples-1;
    //     this.curve[i] = (3+d)*x*20*deg/(Math.PI+d*Math.abs(x));
    //   }
    //   return this.curve;
    // };

  }   //end Sound object

  // BUTTONS HIT TEST AND FUNCTIONALITY
  function myPushyButton(x,y,r,tempId,color){
    //member variables
    this.xPos = x;
    this.yPos = y;
    this.radius = r;
    // new for updating
    this.ellipseID = tempId;
    this.isPressed =false;
    this.color = color;
    // member function (drawing buttons)
   	this.render =function(){
    context.fillStyle = this.color;
    context.beginPath();
    context.arc(this.xPos,this.yPos,this.radius,0, Math.PI * 2, true);
  	context.fill();
    context.closePath();
  }
  // Hit test down, collision detection. Shapeshift on pressing the buttons
  this.hitTestDown =function(){
    if(Math.sqrt(Math.pow((event.clientX-this.xPos),2) + Math.pow((event.clientY - this.yPos),2))< this.radius){
      // When the button is pressed, it changes colour
      this.color = "#505050";

      if(this.ellipseID === 0){
        cross = true;
      	circle = false;
      	square = false;
      } else if(this.ellipseID === 1){
        cross = false;
      	circle = true;
      	square = false;
      } else if(this.ellipseID === 2){
        cross = false;
      	circle = false;
      	square = true;
      }
    } else {
        this.color = color;
    }
  } // end hitTestdown for button
} //end pushyButton

} // end of window load
</script>

</head>
<body>
  <canvas id="testCanvas"></canvas>
</body>
</html>
